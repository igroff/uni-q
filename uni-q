#! /usr/bin/env bash
# vim: ft=sh

WORKING_DIR=${Q_WORKING_DIR:-~/.uni-q}
LOGGING_DIR="${WORKING_DIR}/command_logs"
QUEUE_DIR="${WORKING_DIR}/queue"
PROCESSED_COMMAND_DIR="${WORKING_DIR}/processed"
PROCESS_LOCK_DIR="${WORKING_DIR}/lock.dir"

ERR_DEPENDENCY=1
ERR_LOCK=2
ERR_COMMAND_EXISTS=3
ERR_INVALID_PARAM=4
ERR_NO_COMMAND=5

#############################################################################
## Utils
function error(){ echo $1 >&2; }
function die(){ echo $1 >&2;  exit $2; }

function hash_with_shasum() {
  if which shasum > /dev/null 2>&1 ; then
    function hasher() {
      shasum "${1}" | sed -e 's[  .*[[g'
    }
    return 0
  fi
  return 1
}

function hash_with_openssl() {
  if which openssl > /dev/null 2>&1 ; then
    function hasher() {
      openssl sha "${1}" | sed -e 's[SHA(.*)= [[g'
    }
    return 0
  fi
  return 1
}

function hash_with_md5(){
  if which md5sum > /dev/null 2>&1 ; then
    function hasher() {
      md5sum "${1}" | sed -e 's[  .*[[g'
    }
    return 0
  fi
  return 1
}

function find_a_hasher() {
  case "${HASHER}" in
    "md5")
      hash_with_md5
      ;;
    "shasum")
      hash_with_shasum
      ;;
    "openssl")
      hash_with_openssl
      ;;
    *)
      if hash_with_openssl || hash_with_shasum || hash_with_md5 ; then
        return 0
      else
        return 1
      fi
      ;;
  esac
}
# End Utils
#############################################################################

#############################################################################
# The Program!

if ! mkdir ${PROCESS_LOCK_DIR} > /dev/null 2>&1; then
  die "Unable to acquire lock" $ERR_LOCK
fi

# clean up our lock on exit
trap "rm -rf ${PROCESS_LOCK_DIR}" EXIT

if ! find_a_hasher ; then
  die 'I could not find a hash provider!' $ERR_DEPENDENCY
fi

mkdir -p "$LOGGING_DIR"
mkdir -p "$QUEUE_DIR"
mkdir -p "$PROCESSED_COMMAND_DIR"

function process_queue() {
  local QUEUE_DIR="${1}"
  local LOG_DIR="${2}"
  DID_SOMETHING=
  echo "processing queue: ${QUEUE_DIR}"
  for command in ${QUEUE_DIR}/*
  do
    [ -x "${command}" ] || continue
    FILE_NAME=$(basename "${command}")
    LOG_FILE=${LOG_DIR}/${FILE_NAME}.log
    echo "*** start " $(date +"%x %X") '****************************************' >> ${LOG_FILE}
    $command >> ${LOG_FILE} 2>&1
    echo "*** end " $(date +"%x %X") '****************************************' >> ${LOG_FILE}
    mv "${command}" "${PROCESSED_COMMAND_DIR}/${FILE_NAME}.$(date +"%s")"
    DID_SOMETHING=YES
  done
  # if we didn't run any commands, we tell our caller 1
  [ -z "$DID_SOMETHING" ] && return 1
  # if we did run some commands, we tell our caller 0
  return 0
}

function export_environment(){
  # rewrite our environment as a series of variable declarations followed by their associated exports
  env | cut -f 1,2- --output-delimiter="=" -d= | sed -r -e "s[(^\w*)=(.*$)[\1='\2'; export \1;[g"
}

function generate_queue_stamp(){
    echo "### command enqueued by uni-q " $(date +"%x %X") 
}

function enqueue_command(){
  local COMMAND="${1}"
  local QUEUE_DIR="${2}"
  if [ -x "$COMMAND" ]; then
    # we have a file
    FILE_NAME=${QUEUE_DIR}/$(echo $COMMAND | sed -e 's[\/[_[g')
    [ -x "$FILE_NAME" ] && die "command already queued" $ERR_COMMAND_EXISTS
    export_environment > $FILE_NAME
    echo "####################################################################" >> $FILE_NAME
    echo "# Command" >> $FILE_NAME
    echo $COMMAND >> $FILE_NAME
    echo "####################################################################" >> $FILE_NAME
    generate_queue_stamp >> $FILE_NAME
  else
    # it's on stdin
    TEMP_FILE=$(mktemp)
    trap "[ -f \"$TEMP_FILE\" ] && rm $TEMP_FILE" EXIT
    export_environment > $TEMP_FILE
    cat >> $TEMP_FILE
    FILE_NAME=${QUEUE_DIR}/$(hasher $TEMP_FILE)
    [ -x "$FILE_NAME" ] && die "command already queued" $ERR_COMMAND_EXISTS
    generate_queue_stamp >> $TEMP_FILE
    mv "$TEMP_FILE" "$FILE_NAME"
  fi
  chmod +x $FILE_NAME
  echo "command queued"
}

case "${1}" in
  "process")
    process_queue ${QUEUE_DIR} ${LOGGING_DIR}
    exit
    ;;
  *)
    if [ -n "${1}" -a -f "${1}" -a -x "${1}" ]; then
      COMMAND="${1}"
      # get us an absolute path to the command
      [[ "${COMMAND}" == \/* ]] || COMMAND=$(pwd)/${COMMAND}
    elif [ -n "${1}" ]; then
      die "The parameter provided doesn't appear to refer to a an executable file, you gave me: ${1}" $ERR_INVALID_PARAM
    else
      if [ -t 0 ]; then
        die "You need to provide a command either via stdin or as file on the command line." $ERR_NO_COMMAND
      fi
      # last place to look for a command is stdin
      if read -t 0; then
        COMMAND="STDIN"
      fi
    fi
    if [ -z "${COMMAND}" ]; then
      die "I could not find any commands, sorry" $ERR_NO_COMMAND
    fi
    enqueue_command "${COMMAND}" "${QUEUE_DIR}"
    exit
    ;;
esac
