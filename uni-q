#! /usr/bin/env bash
# vim: ft=sh

WORKING_DIR=${Q_WORKING_DIR:-~/.uni-q}
LOGGING_DIR="${WORKING_DIR}/command_logs"
QUEUE_DIR="${WORKING_DIR}/queue"

#############################################################################
## Utils
function error(){ echo $1 >&2; }
function die(){ echo $1 >&2;  exit $2; }

function hash_with_shasum() {
  if which shasum > /dev/null 2>&1 ; then
    function hasher() {
      shasum "${1}" | sed -e 's[  .*[[g'
    }
    return 0
  fi
  return 1
}

function hash_with_openssl() {
  if which openssl > /dev/null 2>&1 ; then
    function hasher() {
      openssl sha "${1}" | sed -e 's[SHA(.*)= [[g'
    }
    return 0
  fi
  return 1
}

function hash_with_md5(){
  if which md5sum > /dev/null 2>&1 ; then
    function hasher() {
      md5sum "${1}" | sed -e 's[  .*[[g'
    }
    return 0
  fi
  return 1
}

function find_a_hasher() {
  case "${HASHER}" in
    "md5")
      hash_with_md5
      ;;
    "shasum")
      hash_with_shasum
      ;;
    "openssl")
      hash_with_openssl
      ;;
    *)
      if hash_with_openssl || hash_with_shasum || hash_with_md5 ; then
        return 0
      else
        return 1
      fi
      ;;
  esac
}
# End Utils
#############################################################################

#############################################################################
# The Program!
if ! find_a_hasher ; then
  error 'I could not find a hash provider!'
  exit 1
fi

mkdir -p "$LOGGING_DIR"
mkdir -p "$QUEUE_DIR"

function process_queue() {
  local QUEUE_DIR="${1}"
  local LOG_DIR="${2}"
  DID_SOMETHING=
  echo "processing queue: ${QUEUE_DIR}"
  for command in ${QUEUE_DIR}/*
  do
    [ -x "${command}" ] || continue
    FILE_NAME=$(basename "${command}")
    LOG_FILE=${LOG_DIR}/${FILE_NAME}
    echo "*** start " $(date +"%x %X") '****************************************' >> ${LOG_FILE}
    $command >> ${LOG_FILE} 2>&1
    echo "*** end " $(date +"%x %X") '****************************************' >> ${LOG_FILE}
    DID_SOMETHING=YES
  done
  [ -z "$DID_SOMETHING" ] && return 1
  return 0
}

function export_environment(){
  # rewrite our environment as a series of variable declarations followed by their associated exports
  env | cut -f 1,2- --output-delimiter="=" -d= | sed -e "s[\(^\w*\)=\(.*$\)[\1='\2'; export \1;[g"
}

function enqueue_command(){
  local COMMAND="${1}"
  local QUEUE_DIR="${2}"
  if [ -x "$COMMAND" ]; then
    # we have a file
    FILE_NAME=${QUEUE_DIR}/$(echo $COMMAND | sed -e 's[\/[_[g')
    [ -x "$FILE_NAME" ] && die "command already queued" 4
    export_environment >> $FILE_NAME
    echo $COMMAND >> $FILE_NAME
    echo "### enqueued " $(date +"%x %X") >> $FILE_NAME
  else
    # it's on stdin
    TEMP_FILE=$(mktemp)
    trap "[ -f \"$TEMP_FILE\" ] && rm $TEMP_FILE" EXIT
    export_environment >> $TEMP_FILE
    cat >> $TEMP_FILE
    FILE_NAME=${QUEUE_DIR}/$(hasher $TEMP_FILE)
    [ -x "$FILE_NAME" ] && die "command already queued" 4
    echo "### enqueued " $(date +"%x %X") >> $TEMP_FILE
    mv "$TEMP_FILE" "$FILE_NAME"
  fi
  chmod +x $FILE_NAME
  echo "command queued"
}

case "${1}" in
  "process")
    process_queue ${QUEUE_DIR} ${LOGGING_DIR}
    exit
    ;;
  *)
    if [ -n "${1}" -a -f "${1}" -a -x "${1}" ]; then
      COMMAND="${1}"
      # get us an absolute path to the command
      [[ "${COMMAND}" == \/* ]] || COMMAND=$(pwd)/${COMMAND}
    elif [ -n "${1}" ]; then
      error "The parameter provided doesn't appear to refer to a an executable file"
      die "You gave me: ${1}" 1
    else
      if [ -t 0 ]; then
        die "You need to provide a command either via stdin or as file on the command line." 2
      fi
      # last place to look for a command is stdin
      if read -t 0; then
        COMMAND="STDIN"
      fi
    fi
    if [ -z "${COMMAND}" ]; then
      die "I could not find any commands, sorry" 3
    fi
    enqueue_command "${COMMAND}" "${QUEUE_DIR}"
    exit
    ;;
esac
