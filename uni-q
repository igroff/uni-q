#! /usr/bin/env bash
# vim: ft=sh

WORKING_DIR=${Q_WORKING_DIR:-~/.uni-q}
LOGGING_DIR="${WORKING_DIR}/command_logs"
QUEUE_DIR="${WORKING_DIR}/queue"

#############################################################################
## Utils
function hash_with_shasum() {
  if which shasum > /dev/null 2>&1 ; then
    function hasher() {
      shasum "${1}" | sed -e 's[  .*[[g'
    }
    return 0
  fi
  return 1
}

function hash_with_openssl() {
  if which openssl > /dev/null 2>&1 ; then
    function hasher() {
      openssl sha "${1}" | sed -e 's[SHA\(.*\)= [[g'
    }
    return 0
  fi
  return 1
}

function hash_with_md5(){
  if which md5sum > /dev/null 2>&1 ; then
    function hasher() {
      md5sum "${1}" | sed -e 's[  .*[[g'
    }
    return 0
  fi
  return 1
}

function find_a_hasher() {
  case "${HASHER}" in
    "md5")
      hash_with_md5
      ;;
    "shasum")
      hash_with_shasum
      ;;
    "openssl")
      hash_with_openssl
      ;;
    *)
      if hash_with_openssl || hash_with_shasum || hash_with_md5 ; then
        return 0
      else
        return 1
      fi
      ;;
  esac
}
# End Utils
#############################################################################

#############################################################################
# The Program!
if ! find_a_hasher ; then
  echo 'I could not find a hash provider!'
  exit 1
fi

mkdir -p "$LOGGING_DIR"
mkdir -p "$QUEUE_DIR"

function process_queue() {
  WORKING_DIR="${1}"
  echo "processing queue"
  # for each file in the queue dir (dictionary order) that are executable
  # execute the command storing the output in a log file in the logging dir
  # log file will be logging_dir/full_path_to_executable_with_slashes_replaced.log
  #   or in the case of a string command, the hash (I know, sorry).
  # return 0 if we processed any files, otherwise 1
}

function enqueue_command(){
  COMMAND="${1}"
  echo "enqueuing command:"
  echo "${1}"
  # create a command file as queue_dir/full_path_to_executable_with_slashes_replaced.log
  #   or in the case of a string command, the hash
  # write a shebang for bash
  # write to the file the enqueue time as a comment
  # write out the environment variable assignments from the calling environment
  # write the command
  # make the command executable
  # return 0, or 1 if there is any sort of error
}

case "${1}" in
  "process")
    process_queue
    exit
    ;;
  *)
    if [ -n "${1}" -a -f "${1}" -a -x "${1}" ]; then
      COMMAND="${1}"
      # get us an absolute path to the command
      [[ "${COMMAND}" == \/* ]] || COMMAND=$(pwd)/${COMMAND}
    elif [ -n "${1}" ]; then
      echo "The parameter provided doesn't appear to refer to a an executable file" >&2
      echo "You gave me: ${1}" >&2
      exit 1
    else
      if [ -t 0 ]; then
        echo "You need to provide a command either via stdin or as file on the command line." >&2
        exit 2
      fi
      # last place to look for a command is stdin
      if read -t 0; then
        COMMAND=$(cat)
      fi
    fi
    if [ -z "${COMMAND}" ]; then
      echo "I could not find any commands, sorry" >&2
      exit 3
    fi
    enqueue_command "${COMMAND}"
    exit
    ;;
esac

